#! /usr/bin/env mulle-bash
# shellcheck shell=bash

[ "${TRACE}" = 'YES' -o "${MULLE_PROJECT_SOURCETREE_DOCTOR_TRACE}" = 'YES' ] && set -x && : "$0" "$@"


MULLE_EXECUTABLE_VERSION="0.0.0"

if [ -z "${MULLE_PROJECT_LIBEXEC_DIR}" ]
then
   r_get_libexec_dir "${MULLE_EXECUTABLE}" "mulle-project" "mulle-project-git.sh"
   MULLE_PROJECT_LIBEXEC_DIR="${RVAL}"
fi



print_flags()
{
   echo "   -f    : force operation"
   echo "   --fix : fix detected problems automatically"
   ##
   ## ADD YOUR FLAGS DESCRIPTIONS HERE
   ##

   options_technical_flags_usage \
                " : "
}


usage()
{
   [ $# -ne 0 ] && log_error "$*"


   cat <<EOF >&2
Usage:
   mulle-project-sourcetree-doctor [flags] <file>

   Check that a sourcetree looks conventional.

Flags:
EOF
   print_flags | LC_ALL=C sort >&2

   exit 1
}


__doctor_fix_mulle_org_archive()
{
   log_entry "__doctor_fix_mulle_org_archive" "$@"
   
   local address="$1"
   local upcaseid="$2"
   
   log_info "Fixing archive ${address} for mulle organization..."
   
   # Source mulle-sde if needed
   if [ -z "${MULLE_SDE_LIBEXEC_DIR}" ]
   then
      MULLE_SDE_LIBEXEC_DIR="`mulle-sde libexec-dir 2>/dev/null`"
   fi
   
   if [ -f "${MULLE_SDE_LIBEXEC_DIR}/mulle-sde-dependency.sh" ]
   then
      source "${MULLE_SDE_LIBEXEC_DIR}/mulle-sde-common.sh"
      source "${MULLE_SDE_LIBEXEC_DIR}/mulle-sde-dependency.sh"
      
      # Fix tag to use correct upcaseid
      sde::dependency::set_main "${address}" tag "\${${upcaseid}_TAG:-latest}"
   fi
}


__doctor_fix_mulle_org()
{
   log_entry "__doctor_fix_mulle_org" "$@"
   
   local address="$1"
   local user="$2" 
   local repo="$3"
   
   log_info "Fixing ${address} for mulle organization ${user}..."
   
   # Source mulle-sde dependency functions if available
   if [ -z "${MULLE_SDE_LIBEXEC_DIR}" ]
   then
      MULLE_SDE_LIBEXEC_DIR="`mulle-sde libexec-dir 2>/dev/null`"
   fi
   
   if [ ! -f "${MULLE_SDE_LIBEXEC_DIR}/mulle-sde-dependency.sh" ]
   then
      log_error "mulle-sde not available, cannot fix automatically"
      return 1
   fi
   
   # Source required dependencies
   source "${MULLE_SDE_LIBEXEC_DIR}/mulle-sde-common.sh"
   source "${MULLE_SDE_LIBEXEC_DIR}/mulle-sde-dependency.sh"
   
   # Fix nodetype, tag, and URL
   sde::dependency::set_main "${address}" nodetype tar &&
   sde::dependency::set_main "${address}" tag latest &&
   sde::dependency::set_main "${address}" url "https://github.com/${user}/${repo}/archive/\${MULLE_TAG}.tar.gz"
}


__doctor_repo_nodeline()
{
   log_entry "__doctor_repo_nodeline" "$@"

   local upcaseid="$1"

   # Check if this is a mulle GitHub org that should be tar, not git
   case "${_evaledurl}" in
      */github.com/*)
         (
            eval `rexekutor mulle-domain parse-url --domain github "${_evaledurl}" `

            case "${user}" in
               mulle-c|mulle-cc|mulle-gfx|mulle-objc|mulle-core|\
mulle-concurrent|MulleEOF|MulleWeb|MulleFoundation|MulleUI)
                  local needs_fix='NO'
                  
                  if [ "${_evalednodetype}" != "tar" ]
                  then
                     log_warning "${_address}: mulle GitHub org \"${user}\" should use nodetype 'tar', not '${_evalednodetype}'"
                     needs_fix='YES'
                  fi
                  
                  if [ "${_evaledtag}" != "latest" ]
                  then
                     log_warning "${_address}: mulle GitHub org \"${user}\" should use tag 'latest', not '${_evaledtag}'"
                     needs_fix='YES'
                  fi
                  
                  case "${_evaledurl}" in
                     https://github.com/${user}/${repo}/archive/*)
                     ;;
                     *)
                        log_warning "${_address}: mulle GitHub org \"${user}\" should use URL pattern 'https://github.com/${user}/${repo}/archive/\${MULLE_TAG}.tar.gz'"
                        needs_fix='YES'
                     ;;
                  esac
                  
                  if [ "${needs_fix}" = 'YES' -a "${OPTION_FIX}" = 'YES' ]
                  then
                     __doctor_fix_mulle_org "${_address}" "${user}" "${repo}"
                  fi
               ;;
            esac
         )
      ;;
   esac
}


__doctor_archive_nodeline()
{
   log_entry "__doctor_archive_nodeline" "$@"

   local upcaseid="$1"

   local expect
   local defvalue

   defvalue=${_nodetype##*-}
   defvalue=${defvalue%\}}


   expect="\${${upcaseid}_NODETYPE:-${defvalue}}"
   if [ "${_nodetype}" != "${expect}" ]
   then
      log_warning "${_address}: nodetype is \"${_nodetype}\" not \"${expect}\""
   fi

   expect="\${${upcaseid}_URL:-"
   case "${_url}" in
      ${expect}*)
      ;;

      *)
         log_warning "${_address}: url \"${_url}\" does not start with \"${expect}\""
      ;;
   esac

   # Only check for "latest" tag on mulle organizations
   case "${_evaledurl}" in
      */github.com/*)
         (
            eval `rexekutor mulle-domain parse-url --domain github "${_evaledurl}" `
            case "${user}" in
               mulle-c|mulle-cc|mulle-gfx|mulle-objc|mulle-core|\
mulle-concurrent|MulleEOF|MulleWeb|MulleFoundation|MulleUI)
                  # Use the actual upcaseid that was passed in
                  expect="\${${upcaseid}_TAG:-latest}"
                  if [ "${_tag}" != "${expect}" ]
                  then
                     log_warning "${_address}: tag is \"${_tag}\" not \"${expect}\""
                     if [ "${OPTION_FIX}" = 'YES' ]
                     then
                        __doctor_fix_mulle_org_archive "${_address}" "${upcaseid}"
                     fi
                  fi
               ;;
            esac
         )
      ;;
   esac

   expect="\${${upcaseid}_BRANCH}"
   if [ "${_branch}" != "${expect}" ]
   then
      # Check for empty default pattern
      case "${_branch}" in
         *:-\})
            log_warning "${_address}: branch is \"${_branch}\" not \"${expect}\""
            if [ "${OPTION_FIX}" = 'YES' ]
            then
               __doctor_fix_empty_default "${_address}" "branch" "${_branch}"
            fi
         ;;
         *)
            log_warning "${_address}: branch is \"${_branch}\" not \"${expect}\""
         ;;
      esac
   fi

   case "${_url}" in
      *\${MULLE_TAG\}*)
      ;;

      *\${MULLE_*)
         log_warning "${_address}: URL \"${_url}\" should use \"\${MULLE_TAG}\" without a default"
      ;;

      *)
         log_warning "${_address}: URL \"${_url}\" should use \"\${MULLE_TAG}\" in URL"
      ;;
   esac

   case "${_evaledurl}" in
      "")
         log_warning "${_address}: URL \"${_url}\" evaluates to empty"
      ;;

      */github.com/*)
         (
            eval `rexekutor mulle-domain parse-url --domain github "${_evaledurl}" `

            if [ -z "${repo}" ]
            then
               log_warning "${_address}: URL \"${_url} specifies no github repository\""
            fi

            case "${user}" in
               mulle-c|mulle-cc|mulle-gfx|mulle-objc|mulle-core|\
mulle-concurrent|MulleEOF|MulleWeb|MulleFoundation|MulleUI)
               ;;

               codeon-gmbh)
                  log_warning "${_address}: URL \"${_url} specifies obsolete github user \"${user}\""
               ;;

               mulle-nat)
                  case "${repo}" in
                     libexpat)
                     ;;

                     *)
                        log_warning "${_address}: URL \"${_url} references mulle-nat"
                     ;;
                  esac
               ;;


               ""|"."|"..")
                  log_warning "${_address}: URL \"${_url} specifies no github user"
               ;;

               *)
                  log_info "${_address}: URL \"${_url} specifies non-mulle github user \"${user}\""
               ;;
            esac
         )
      ;;

      *)
         log_info "${_address}: URL \"${_url} is not on github"
      ;;
   esac
}


r_count_character()
{
   local s="$1"
   local c="$2"

   RVAL="${s//[^${c}]/}"
   RVAL="${#RVAL}"
}


is_balanced_character_pair()
{
   local s="$1"
   local pair="$2"

   local n
   local m

   r_count_character "${s}" "${pair:0:1}"
   n="${RVAL}"

   r_count_character "${s}" "${pair:1:1}"
   m="${RVAL}"

   [ $n -eq $m ]
}


r_extract_env_vars()
{
   log_entry "r_extract_env_vars" "$@"
   
   local text="$1"
   
   # Extract ${VAR_NAME} and ${VAR_NAME:-default} patterns
   RVAL="`printf '%s\n' "${text}" | sed -n 's/.*\${\([^}]*\)}.*/\1/gp' | sed 's/:-.*$//'`"
}


doctor_check_environment_variables()
{
   log_entry "doctor_check_environment_variables" "$@"
   
   local address="$1"
   
   # Check all fields for environment variables
   local field
   local vars
   local var
   
   for field in "${_nodetype}" "${_tag}" "${_branch}" "${_url}"
   do
      if [ ! -z "${field}" ]
      then
         r_extract_env_vars "${field}"
         vars="${RVAL}"
         
         .foreachline var in ${vars}
         .do
            if [ ! -z "${var}" ]
            then
               # Check if variable is set in environment
               if ! printenv "${var}" >/dev/null 2>&1
               then
                  log_warning "${address}: environment variable \${${var}} is not defined"
                  
                  if [ "${OPTION_FIX}" = 'YES' ]
                  then
                     __doctor_fix_missing_env_var "${address}" "${var}"
                  fi
               fi
            fi
         .done
      fi
   done
}


__doctor_fix_unbalanced_braces()
{
   log_entry "__doctor_fix_unbalanced_braces" "$@"
   
   local address="$1"
   local field="$2"
   local value="$3"
   
   log_info "Fixing unbalanced braces in ${field} for ${address}..."
   
   # Count braces
   r_count_character "${value}" "{"
   local open_count="${RVAL}"
   r_count_character "${value}" "}"
   local close_count="${RVAL}"
   
   if [ ${open_count} -gt ${close_count} ]
   then
      # Add missing closing braces
      local missing=$((open_count - close_count))
      local fixed_value="${value}"
      while [ ${missing} -gt 0 ]
      do
         fixed_value="${fixed_value}}"
         missing=$((missing - 1))
      done
      
      # Source mulle-sde if needed
      if [ -z "${MULLE_SDE_LIBEXEC_DIR}" ]
      then
         MULLE_SDE_LIBEXEC_DIR="`mulle-sde libexec-dir 2>/dev/null`"
      fi
      
      if [ -f "${MULLE_SDE_LIBEXEC_DIR}/mulle-sde-dependency.sh" ]
      then
         source "${MULLE_SDE_LIBEXEC_DIR}/mulle-sde-common.sh"
         source "${MULLE_SDE_LIBEXEC_DIR}/mulle-sde-dependency.sh"
         
         sde::dependency::set_main "${address}" "${field}" "${fixed_value}"
      fi
   fi
}


__doctor_fix_empty_default()
{
   log_entry "__doctor_fix_empty_default" "$@"
   
   local address="$1"
   local field="$2"
   local value="$3"
   
   log_info "Fixing empty default in ${field} for ${address}..."
   
   # Remove :-} and replace with }
   local fixed_value="${value/:-\}/\}}"
   
   # Source mulle-sde if needed
   if [ -z "${MULLE_SDE_LIBEXEC_DIR}" ]
   then
      MULLE_SDE_LIBEXEC_DIR="`mulle-sde libexec-dir 2>/dev/null`"
   fi
   
   if [ -f "${MULLE_SDE_LIBEXEC_DIR}/mulle-sde-dependency.sh" ]
   then
      source "${MULLE_SDE_LIBEXEC_DIR}/mulle-sde-common.sh"
      source "${MULLE_SDE_LIBEXEC_DIR}/mulle-sde-dependency.sh"
      
      sde::dependency::set_main "${address}" "${field}" "${fixed_value}"
   fi
}


doctor_check_variable_wrapping()
{
   log_entry "doctor_check_variable_wrapping" "$@"
   
   local address="$1"
   local upcaseid="$2"
   
   # Skip variable wrapping checks for special nodetypes
   case "${_nodetype}" in
      *none*|*comment*|*local*)
         return 0
      ;;
   esac
   
   # Skip variable wrapping checks for no-share-shirk entries (they use ${VAR} format)
   if [[ "${_marks}" == *"no-share-shirk"* ]]
   then
      return 0
   fi
   
   # Check if nodetype is properly wrapped
   case "${_nodetype}" in
      \$\{${upcaseid}_NODETYPE:-*\})
         # properly wrapped
      ;;
      *)
         # Don't suggest wrapping if it's already a variable reference
         case "${_nodetype}" in
            \$\{*\})
               # Already a variable, don't suggest wrapping
            ;;
            *)
               log_warning "${address}: nodetype \"${_nodetype}\" should be wrapped as \${${upcaseid}_NODETYPE:-${_nodetype}}"
               if [ "${OPTION_FIX}" = 'YES' ]
               then
                  __doctor_fix_variable_wrapping "${address}" "nodetype" "${_nodetype}" "${upcaseid}"
               fi
            ;;
         esac
      ;;
   esac
   
   # Check if tag is properly wrapped  
   case "${_tag}" in
      \$\{${upcaseid}_TAG:-*\})
         # properly wrapped
      ;;
      *)
         if [ ! -z "${_tag}" ]
         then
            # Don't suggest wrapping if it's already a variable reference
            case "${_tag}" in
               \$\{*\})
                  # Already a variable, don't suggest wrapping
               ;;
               *)
                  log_warning "${address}: tag \"${_tag}\" should be wrapped as \${${upcaseid}_TAG:-${_tag}}"
                  if [ "${OPTION_FIX}" = 'YES' ]
                  then
                     __doctor_fix_variable_wrapping "${address}" "tag" "${_tag}" "${upcaseid}"
                  fi
               ;;
            esac
         fi
      ;;
   esac
   
   # Check if branch is properly wrapped
   case "${_branch}" in
      \$\{${upcaseid}_BRANCH*\})
         # properly wrapped (can be with or without default)
      ;;
      *)
         if [ ! -z "${_branch}" ]
         then
            # Don't suggest wrapping if it's already a variable reference
            case "${_branch}" in
               \$\{*\})
                  # Already a variable, don't suggest wrapping
               ;;
               *)
                  log_warning "${address}: branch \"${_branch}\" should be wrapped as \${${upcaseid}_BRANCH:-${_branch}}"
                  if [ "${OPTION_FIX}" = 'YES' ]
                  then
                     __doctor_fix_variable_wrapping "${address}" "branch" "${_branch}" "${upcaseid}"
                  fi
               ;;
            esac
         else
            # Check for empty default that should be removed
            case "${_branch}" in
               *:-\})
                  log_warning "${address}: branch \"${_branch}\" should be wrapped as \${${upcaseid}_BRANCH}"
                  if [ "${OPTION_FIX}" = 'YES' ]
                  then
                     __doctor_fix_empty_default "${address}" "branch" "${_branch}"
                  fi
               ;;
               *)
                  log_warning "${address}: branch \"${_branch}\" should be wrapped as \${${upcaseid}_BRANCH}"
                  if [ "${OPTION_FIX}" = 'YES' ]
                  then
                     __doctor_fix_variable_wrapping "${address}" "branch" "" "${upcaseid}"
                  fi
               ;;
            esac
         fi
      ;;
   esac
   
   # Check if URL is properly wrapped
   case "${_url}" in
      \$\{${upcaseid}_URL:-*\})
         # properly wrapped
      ;;
      *)
         # Don't suggest wrapping if it's already a variable reference
         case "${_url}" in
            \$\{*\})
               # Already a variable, don't suggest wrapping
            ;;
            *)
               log_warning "${address}: url \"${_url}\" should be wrapped as \${${upcaseid}_URL:-${_url}}"
               if [ "${OPTION_FIX}" = 'YES' ]
               then
                  __doctor_fix_variable_wrapping "${address}" "url" "${_url}" "${upcaseid}"
               fi
            ;;
         esac
      ;;
   esac
}


__doctor_fix_variable_wrapping()
{
   log_entry "__doctor_fix_variable_wrapping" "$@"
   
   local address="$1"
   local field="$2"
   local value="$3"
   local upcaseid="$4"
   
   log_info "Wrapping ${field} for ${address}..."
   
   # Source mulle-sde if needed
   if [ -z "${MULLE_SDE_LIBEXEC_DIR}" ]
   then
      MULLE_SDE_LIBEXEC_DIR="`mulle-sde libexec-dir 2>/dev/null`"
   fi
   
   if [ -f "${MULLE_SDE_LIBEXEC_DIR}/mulle-sde-dependency.sh" ]
   then
      source "${MULLE_SDE_LIBEXEC_DIR}/mulle-sde-common.sh"
      source "${MULLE_SDE_LIBEXEC_DIR}/mulle-sde-dependency.sh"
      
      r_uppercase "${field}"
      local wrapped_value
      if [ -z "${value}" ]
      then
         wrapped_value="\${${upcaseid}_${RVAL}}"
      else
         wrapped_value="\${${upcaseid}_${RVAL}:-${value}}"
      fi
      sde::dependency::set_main "${address}" "${field}" "${wrapped_value}"
   fi
}


doctor_nodeline()
{
   log_entry "doctor_nodeline" "$@"

   local nodeline="$1"

   local _branch
   local _address
   local _fetchoptions
   local _nodetype
   local _marks
   local _raw_userinfo
   local _userinfo
   local _tag
   local _url
   local _uuid

   sourcetree::nodeline::parse "${nodeline}"

   if ! is_balanced_character_pair "${_branch}" "{}"
   then
      log_warning "${_address}: branch ${_branch} has unbalanced {} characters"
      if [ "${OPTION_FIX}" = 'YES' ]
      then
         __doctor_fix_unbalanced_braces "${_address}" "branch" "${_branch}"
      fi
   fi
   if ! is_balanced_character_pair "${_tag}" "{}"
   then
      log_warning "${_address}: tag ${_tag} has unbalanced {} characters"
      if [ "${OPTION_FIX}" = 'YES' ]
      then
         __doctor_fix_unbalanced_braces "${_address}" "tag" "${_tag}"
      fi
   fi
   if ! is_balanced_character_pair "${_nodetype}" "{}"
   then
      log_warning "${_address}: nodetype ${_nodetype} has unbalanced {} characters"
      if [ "${OPTION_FIX}" = 'YES' ]
      then
         __doctor_fix_unbalanced_braces "${_address}" "nodetype" "${_nodetype}"
      fi
   fi
   if ! is_balanced_character_pair "${_url}" "{}"
   then
      log_warning "${_address}: url ${_url} has unbalanced {} characters"
      if [ "${OPTION_FIX}" = 'YES' ]
      then
         __doctor_fix_unbalanced_braces "${_address}" "url" "${_url}"
      fi
   fi

   local upcaseid

   include "case"

   case "${_address}" in
      craftinfo/*)
         RVAL="${_address}"
      ;;

      *)
         r_basename "${_address}"
      ;;
   esac

   r_smart_file_upcase_identifier "${RVAL}"
   upcaseid="${RVAL}"

   # Check if variables are properly wrapped
   doctor_check_variable_wrapping "${_address}" "${upcaseid}"

   if find_line "${UPCASEIDS}" "${upcaseid}"
   then
      log_warning "${_address}: ${upcaseid} might be a duplicate of another address"
   else
      r_add_line "${UPCASEIDS}" "${upcaseid}"
      UPCASEIDS="${RVAL}"
   fi

   local _evaledurl
   local _evalednodetype
   local _evaledbranch
   local _evaledtag
   local _evaledfetchoptions

   sourcetree::node::__evaluate_values

   case "${_evalednodetype}" in
      'git'|'svn')
         __doctor_repo_nodeline "${upcaseid}"
      ;;

      'tar'|'zip')
         __doctor_archive_nodeline "${upcaseid}"
      ;;
   esac
}

UPCASEIDS=

main()
{
   #
   # simple flag handling
   #
   while [ $# -ne 0 ]
   do
      if options_technical_flags "$1"
      then
         shift
         continue
      fi

      case "$1" in
         -f|--force)
            MULLE_FLAG_MAGNUM_FORCE='YES'
         ;;

         --fix)
            OPTION_FIX='YES'
         ;;

         -h*|--help|help)
            usage
         ;;

         --version)
            printf "%s\n" "${MULLE_EXECUTABLE_VERSION}"
            exit 0
         ;;

         -*)
            usage "Unknown flag \"$1\""
         ;;

         *)
            break
         ;;
      esac

      shift
   done

   options_setup_trace "${MULLE_TRACE}" && set -x

   include "sourcetree::environment"

   sourcetree::environment::setup "${OPTION_SHAREDIR}"

   include "sourcetree::cfg"
   include "sourcetree::nodeline"
   include "case"

   local nodelines
   local nodeline

   nodelines="`sourcetree::cfg::read "${1:-/}" `" || exit 1
   .foreachline nodeline in ${nodelines}
   .do
      doctor_nodeline "${nodeline}"
   .done
}


call_with_flags "main" "${MULLE_PROJECT_SOURCETREE_DOCTOR_FLAGS}" "$@"
